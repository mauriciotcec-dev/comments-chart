name: CI - Deploy chart to OpenShift (uses oc + namespace from values.yaml)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenShift client (oc) and kubectl safely
        run: |
          set -euo pipefail
          echo "Downloading OpenShift client to runner temp (not repo tree)..."
          TARBALL_URL="https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz"
          TDIR="${RUNNER_TEMP:-/tmp}"
          mkdir -p "$TDIR"
          curl -fsSL -o "$TDIR/openshift-client-linux.tar.gz" "$TARBALL_URL"
          tar -xzf "$TDIR/openshift-client-linux.tar.gz" -C "$TDIR"
          sudo mv "$TDIR/oc" /usr/local/bin/oc
          # kubectl may or may not exist in the tar; ignore error if absent
          sudo mv "$TDIR/kubectl" /usr/local/bin/kubectl || true
          # cleanup tarball and extracted files in runner temp
          rm -f "$TDIR/openshift-client-linux.tar.gz"
          rm -f "$TDIR/oc" "$TDIR/kubectl" || true
          echo "oc version:"
          oc version --client

      - name: Login to OpenShift
        env:
          OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
          OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
          OPENSHIFT_INSECURE: ${{ secrets.OPENSHIFT_INSECURE }}
        run: |
          if [ -z "${OPENSHIFT_SERVER}" ] || [ -z "${OPENSHIFT_TOKEN}" ]; then
            echo "ERROR: OPENSHIFT_SERVER and OPENSHIFT_TOKEN secrets must be set"
            exit 1
          fi

          if [ "${OPENSHIFT_INSECURE:-false}" = "true" ]; then
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}" --insecure-skip-tls-verify=true
          else
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}"
          fi

      - name: Read namespace from chart values.yaml
        id: read_ns
        run: |
          # Buscar el primer values.yaml en el repo (ajusta -maxdepth si tu layout es más profundo)
          VALUES_FILE=$(find . -maxdepth 3 -type f -name values.yaml | head -n1 || true)

          if [ -z "$VALUES_FILE" ]; then
            echo "WARNING: values.yaml not found in repo root or charts/; using default namespace"
            NAMESPACE="comments-namespace"
          else
            echo "Found values file: $VALUES_FILE"
            # Extraer la primera ocurrencia de 'namespace: <valor>' (ignora comentarios)
            NAMESPACE=$(grep -E '^[[:space:]]*namespace[[:space:]]*:' "$VALUES_FILE" | head -n1 | awk -F':' '{val=$2; sub(/^[ \t]+/,"",val); sub(/[ \t]+$/,"",val); print val}')
            # Quitar comillas si existen
            NAMESPACE=$(echo "$NAMESPACE" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")
            if [ -z "$NAMESPACE" ]; then
              echo "No 'namespace:' key found in $VALUES_FILE; using default namespace"
              NAMESPACE="comments-namespace"
            fi
          fi

          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Ensure namespace exists (do NOT create)
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          echo "Using namespace: ${NAMESPACE}"

          if oc get namespace "${NAMESPACE}" >/dev/null 2>&1; then
            echo "Namespace ${NAMESPACE} exists — continuing."
          else
            echo ""
            echo "ERROR: Namespace '${NAMESPACE}' does not exist."
            echo "This CI does NOT attempt to create namespaces. Please ask a cluster administrator to run:"
            echo ""
            echo "  oc create namespace ${NAMESPACE}"
            echo "  oc create serviceaccount <SA_NAME> -n ${NAMESPACE}     # if SA not already created"
            echo "  oc adm policy add-role-to-user edit system:serviceaccount:${NAMESPACE}:<SA_NAME> -n ${NAMESPACE}"
            echo ""
            echo "Then set OPENSHIFT_SERVER and OPENSHIFT_TOKEN (token for that ServiceAccount) as repository secrets and re-run the workflow."
            echo ""
            exit 1
          fi

      - name: Ensure Docker Hub pull secret exists (idempotent)
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          # Crear/actualizar secret docker-registry (idempotente)
          oc create secret docker-registry regcred \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username="${DOCKERHUB_USERNAME}" \
            --docker-password="${DOCKERHUB_TOKEN}" \
            --dry-run=client -o yaml | oc -n "${NAMESPACE}" apply -f -
          # Link secret al serviceaccount default para pull (opcional)
          oc -n "${NAMESPACE}" secrets link default regcred --for=pull || true

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Helm upgrade --install
        env:
          HELM_EXPERIMENTAL_OCI: 0
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          # Removed --create-namespace to avoid Helm attempting cluster-scoped namespace creation
          helm upgrade --install comments-release ./ -n "${NAMESPACE}" \
            --set images.frontend.tag=${{ .Values.images.frontend.tag }} \
            --set images.backendApi.tag=${{ .Values.images.backendApi.tag }} \
            --set images.backendData.tag=${{ .Values.images.backendData.tag }} \
            --set-string mongodb.password="${{ secrets.MONGO_PASSWORD }}" \
            --wait --timeout 10m --atomic
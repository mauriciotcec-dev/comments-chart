name: CI - Deploy chart to OpenShift (uses oc + namespace from values.yaml)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install oc (OpenShift client)
        run: |
          curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz
          tar -xzf openshift-client-linux.tar.gz -C /tmp
          sudo mv /tmp/oc /usr/local/bin/oc
          sudo mv /tmp/kubectl /usr/local/bin/kubectl || true
          oc version

      - name: Login to OpenShift
        env:
          OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
          OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
          OPENSHIFT_INSECURE: ${{ secrets.OPENSHIFT_INSECURE }}
        run: |
          if [ -z "${OPENSHIFT_SERVER}" ] || [ -z "${OPENSHIFT_TOKEN}" ]; then
            echo "ERROR: OPENSHIFT_SERVER and OPENSHIFT_TOKEN secrets must be set"
            exit 1
          fi

          if [ "${OPENSHIFT_INSECURE:-false}" = "true" ]; then
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}" --insecure-skip-tls-verify=true
          else
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}"
          fi

      - name: Render chart to YAML (real values, temporary for debug)
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          CHART_PATH="./"   # ajusta si tu chart está en otra ruta (ej. ./comments-chart)
          helm template comments-release "${CHART_PATH}" -n "${NAMESPACE}" \
            --set images.frontend.repository="docker.io/${{ secrets.DOCKERHUB_USERNAME }}/frontend" \
            --set images.frontend.tag="${{ github.sha }}" \
            --set images.backendApi.repository="docker.io/${{ secrets.DOCKERHUB_USERNAME }}/backend-api" \
            --set images.backendApi.tag="${{ github.sha }}" \
            --set images.backendData.repository="docker.io/${{ secrets.DOCKERHUB_USERNAME }}/backend-data" \
            --set images.backendData.tag="${{ github.sha }}" \
            --set-string mongodb.password="${{ secrets.MONGO_PASSWORD }}" \
            --include-crds > rendered.real.yaml

      - name: Create identify_failing_doc.sh (temporary) and run it
        run: |
          cat > identify_failing_doc.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          RENDERED="${1:-rendered.real.yaml}"
          NAMESPACE="${2:-$NAMESPACE}"
          CMD="${3:-oc}"
          TMP="$(mktemp -d)"
          trap 'rm -rf "$TMP"' EXIT
          csplit -z -f "$TMP/xx" "$RENDERED" '/^---$/' '{*}' >/dev/null 2>&1 || true
          files=( "$TMP"/xx* )
          if [ "${#files[@]}" -eq 0 ]; then
            cp "$RENDERED" "$TMP/xx000"
            files=( "$TMP"/xx000 )
          fi
          i=0
          for f in "${files[@]}"; do
            i=$((i+1))
            size=$(wc -c <"$f")
            echo
            echo "=== doc #$i - bytes: $size - file: $f ==="
            grep -m1 -n '^# Source:' "$f" || true
            echo "-> dry-run=server ..."
            if ! $CMD apply -n "$NAMESPACE" -f "$f" --dry-run=server >/dev/null 2>&1; then
              echo "DRY-RUN FAILED for doc #$i. Capturing server error..."
              if ! $CMD apply -n "$NAMESPACE" -f "$f" 2> "$TMP/error_$i.txt"; then
                echo "=== ERROR for doc #$i ==="
                sed -n '1,200p' "$TMP/error_$i.txt"
                echo "---- first 200 lines of the document ----"
                sed -n '1,200p' "$f"
                exit 3
              fi
            else
              echo "DRY-RUN ok for doc #$i."
            fi
          done
          echo "All documents dry-run ok."
          EOF
          chmod +x identify_failing_doc.sh
          # Ejecutar el script (NAMESPACE ya definido arriba)
          ./identify_failing_doc.sh rendered.real.yaml "${NAMESPACE}" oc > apply_detection.txt || true

      - name: Upload apply detection report
        uses: actions/upload-artifact@v4
        with:
          name: helm-apply-detection-report
          path: apply_detection.txt
          
      - name: Read namespace from chart values.yaml
        id: read_ns
        run: |
          # Buscar el primer values.yaml en el repo (ajusta -maxdepth si tu layout es más profundo)
          VALUES_FILE=$(find . -maxdepth 3 -type f -name values.yaml | head -n1 || true)

          if [ -z "$VALUES_FILE" ]; then
            echo "WARNING: values.yaml not found in repo root or charts/; using default namespace"
            NAMESPACE="comments-namespace"
          else
            echo "Found values file: $VALUES_FILE"
            # Extraer la primera ocurrencia de 'namespace: <valor>' (ignora comentarios)
            NAMESPACE=$(grep -E '^[[:space:]]*namespace[[:space:]]*:' "$VALUES_FILE" | head -n1 | awk -F':' '{val=$2; sub(/^[ \t]+/,"",val); sub(/[ \t]+$/,"",val); print val}')
            # Quitar comillas si existen
            NAMESPACE=$(echo "$NAMESPACE" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")
            if [ -z "$NAMESPACE" ]; then
              echo "No 'namespace:' key found in $VALUES_FILE; using default namespace"
              NAMESPACE="comments-namespace"
            fi
          fi

          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Ensure namespace exists (do NOT create)
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          echo "Using namespace: ${NAMESPACE}"

          if oc get namespace "${NAMESPACE}" >/dev/null 2>&1; then
            echo "Namespace ${NAMESPACE} exists — continuing."
          else
            echo ""
            echo "ERROR: Namespace '${NAMESPACE}' does not exist."
            echo "This CI does NOT attempt to create namespaces. Please ask a cluster administrator to run:"
            echo ""
            echo "  oc create namespace ${NAMESPACE}"
            echo "  oc create serviceaccount <SA_NAME> -n ${NAMESPACE}     # if SA not already created"
            echo "  oc adm policy add-role-to-user edit system:serviceaccount:${NAMESPACE}:<SA_NAME> -n ${NAMESPACE}"
            echo ""
            echo "Then set OPENSHIFT_SERVER and OPENSHIFT_TOKEN (token for that ServiceAccount) as repository secrets and re-run the workflow."
            echo ""
            exit 1
          fi

      - name: Ensure Docker Hub pull secret exists (idempotent)
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          # Crear/actualizar secret docker-registry (idempotente)
          oc create secret docker-registry regcred \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username="${DOCKERHUB_USERNAME}" \
            --docker-password="${DOCKERHUB_TOKEN}" \
            --dry-run=client -o yaml | oc -n "${NAMESPACE}" apply -f -
          # Link secret al serviceaccount default para pull (opcional)
          oc -n "${NAMESPACE}" secrets link default regcred --for=pull || true

      - name: Set up Helm
        uses: azure/setup-helm@v3
      - name: Render chart to YAML (safe)
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          CHART_PATH="./"   # ajusta si tu chart está en otra ruta (ej. ./comments-chart)
          helm template comments-release "${CHART_PATH}" -n "${NAMESPACE}" \
            --set images.frontend.repository="docker.io/REPLACE_WITH_USER/frontend" \
            --set images.backendApi.repository="docker.io/REPLACE_WITH_USER/backend-api" \
            --set images.backendData.repository="docker.io/REPLACE_WITH_USER/backend-data" \
            --set-string mongodb.password="REDACTED_PLACEHOLDER" \
            --include-crds > rendered.yaml

      - name: Upload rendered.yaml (safe)
        uses: actions/upload-artifact@v4
        with:
          name: rendered-safe
          path: rendered.yaml
      - name: Helm upgrade --install
        env:
          HELM_EXPERIMENTAL_OCI: 0
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          # Removed --create-namespace to avoid Helm attempting cluster-scoped namespace creation
          helm upgrade --install comments-release ./ -n "${NAMESPACE}" \
            --set images.frontend.tag=${{ github.sha }} \
            --set images.backendApi.tag=${{ github.sha }} \
            --set images.backendData.tag=${{ github.sha }} \
            --set-string mongodb.password="${{ secrets.MONGO_PASSWORD }}" \
            --wait --timeout 10m --atomic
name: CI - Deploy chart to OpenShift (uses oc + namespace from values.yaml)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install oc (OpenShift client)
        run: |
          curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz
          tar -xzf openshift-client-linux.tar.gz -C /tmp
          sudo mv /tmp/oc /usr/local/bin/oc
          sudo mv /tmp/kubectl /usr/local/bin/kubectl || true
          oc version

      - name: Login to OpenShift
        env:
          OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
          OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
          OPENSHIFT_INSECURE: ${{ secrets.OPENSHIFT_INSECURE }}
        run: |
          if [ -z "${OPENSHIFT_SERVER}" ] || [ -z "${OPENSHIFT_TOKEN}" ]; then
            echo "ERROR: OPENSHIFT_SERVER and OPENSHIFT_TOKEN secrets must be set"
            exit 1
          fi

          if [ "${OPENSHIFT_INSECURE:-false}" = "true" ]; then
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}" --insecure-skip-tls-verify=true
          else
            oc login "${OPENSHIFT_SERVER}" --token="${OPENSHIFT_TOKEN}"
          fi

      - name: Read namespace from chart values.yaml
        id: read_ns
        run: |
          # Buscar el primer values.yaml en el repo (ajusta -maxdepth si tu layout es m√°s profundo)
          VALUES_FILE=$(find . -maxdepth 3 -type f -name values.yaml | head -n1 || true)

          if [ -z "$VALUES_FILE" ]; then
            echo "WARNING: values.yaml not found in repo root or charts/; using default namespace"
            NAMESPACE="comments-namespace"
          else
            echo "Found values file: $VALUES_FILE"
            # Extraer la primera ocurrencia de 'namespace: <valor>' (ignora comentarios)
            NAMESPACE=$(grep -E '^[[:space:]]*namespace[[:space:]]*:' "$VALUES_FILE" | head -n1 | awk -F':' '{val=$2; sub(/^[ \t]+/,"",val); sub(/[ \t]+$/,"",val); print val}')
            # Quitar comillas si existen
            NAMESPACE=$(echo "$NAMESPACE" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")
            if [ -z "$NAMESPACE" ]; then
              echo "No 'namespace:' key found in $VALUES_FILE; using default namespace"
              NAMESPACE="comments-namespace"
            fi
          fi

          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Ensure namespace and Docker Hub pull secret (try create, fail with helpful message)
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          echo "Using namespace: ${NAMESPACE}"

          # If namespace exists, continue
          if oc get namespace "${NAMESPACE}" >/dev/null 2>&1; then
            echo "Namespace ${NAMESPACE} already exists."
          else
            echo "Namespace ${NAMESPACE} does not exist. Attempting to create..."
            # Try to create the namespace idempotently
            if oc create namespace "${NAMESPACE}" --dry-run=client -o yaml | oc apply -f -; then
              echo "Namespace ${NAMESPACE} created or applied successfully."
            else
              echo ""
              echo "ERROR: Could not create or apply namespace ${NAMESPACE}."
              echo "This typically means the ServiceAccount used by the CI does not have permission to create namespaces (namespaces are cluster-scoped)."
              echo ""
              echo "Options to resolve:"
              echo "1) Ask a cluster administrator to create the namespace and grant the CI ServiceAccount 'edit' in that namespace:"
              echo ""
              echo "   # As cluster-admin (replace NAMESPACE and <SA_NAME>):"
              echo "   oc create namespace ${NAMESPACE}"
              echo "   oc create serviceaccount <SA_NAME> -n ${NAMESPACE}     # if SA not already created"
              echo "   oc adm policy add-role-to-user edit system:serviceaccount:${NAMESPACE}:<SA_NAME> -n ${NAMESPACE}"
              echo ""
              echo "2) If you want the CI to be able to create namespaces (less recommended), ask an admin to grant a ClusterRole/ClusterRoleBinding allowing namespace creation."
              echo ""
              echo "After the namespace exists and the ServiceAccount has 'edit' in that namespace, re-run this workflow."
              echo ""
              exit 1
            fi
          fi

          # Create/ensure docker-registry secret in the namespace (idempotent)
          oc create secret docker-registry regcred \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username="${DOCKERHUB_USERNAME}" \
            --docker-password="${DOCKERHUB_TOKEN}" \
            --dry-run=client -o yaml | oc -n "${NAMESPACE}" apply -f -

          # Link secret to default serviceaccount for image pulls (optional; ignore error)
          oc -n "${NAMESPACE}" secrets link default regcred --for=pull || true

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Helm upgrade --install
        env:
          HELM_EXPERIMENTAL_OCI: 0
        run: |
          NAMESPACE="${{ steps.read_ns.outputs.namespace }}"
          helm upgrade --install comments-release ./ -n "${NAMESPACE}" \
            --set images.frontend.tag=${{ github.sha }} \
            --set images.backendApi.tag=${{ github.sha }} \
            --set images.backendData.tag=${{ github.sha }} \
            --set-string mongodb.password="${{ secrets.MONGO_PASSWORD }}" \
            --wait